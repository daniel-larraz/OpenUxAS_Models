-- waypoint-manager.lus

include "../common/types.lus"
include "../common/pltl.lus"
include "../common/route-utils.lus"


contract wm_contract(
    -- The message currently received by the service
    in_msg : message;

    -- The ID to be used for ID generation
    in_id : id_type;

    -- True if the service is permitted to send a message.
    can_send_message : bool;
) returns (
    -- The message currently sent by the service
    out_msg : message;
);
let
    guarantee "Waypoint Manager R1. IC.
      The Waypoint Manager initial condition is to send no message.\n  "
    (
        (out_msg = no_message) -> true
    );

    guarantee "Waypoint Manager R2. Respects bus access.
      The Waypoint Manager does not send a message when instructed not to.\n  "
    (
        not can_send_message
    ) => (
        out_msg = no_message
    );


    mode No_Message (
        require (
            out_msg = no_message
        );
    );

    mode Mission_Command (
        require (
            out_msg <> no_message
        );

        ensure "Waypoint Manager R3. Message IDs.
          The Waypoint Manager correctly computes output message IDs.\n  "
        (
            out_msg.id = in_id + 1
        );

        ensure "Waypoint Manager R4. Only Response.
          The Waypoint Manager only sends Mission_Command messages.\n  "
        (
            out_msg.kind = mission_command
        );

        ensure "Waypoint Manager R5.
          When the Waypoint Manager sends a Mission Command message, the
          waypoint sent is contained in the route that belongs to the
          previously received Automation Response message that is referenced in
          the Mission Command message.\n  "
        (
          exists (m: history(in_msg))
            m.kind  = automation_response and
            m.id    = out_msg.ref and
            m.route = out_msg.route and
            contains(out_msg.route, out_msg.waypoint)
        );
    );
tel;


--
-- The Waypoint Manager Service
--
node waypoint_manager(
    -- The message currently received by the service
    in_msg : message;

    -- The ID to be used for ID generation
    in_id : id_type;

    -- True if the service is permitted to send a message.
    can_send_message : bool;
) returns (
    -- The message currently sent by the service
    out_msg : message;
);
(*@contract
    import wm_contract(in_msg, in_id, can_send_message) returns (out_msg);
*)
var
    -- ===================================================================== --
    -- Service state
    --
    -- The route from which this service will stream waypoints
    route : route_type;

    -- The ID of the message that provided the route above
    route_msg_id : id_type;

    -- The waypoint to send
    waypoint : waypoint_type;
let
    -- ===================================================================== --
    -- Service Behavior

    -- These expressions serve as high-level specifications of service
    -- behavior. Each is preceded by a natural-language description of the
    -- specification, set off in quotes for clarity.

    -- "If there is a stored route, the service shall get the next waypoint
    --  from the route."
    --
    -- Note that this happens "before" we determine if there is a new route.
    waypoint = next_waypoint(no_route -> pre(route));


    -- "If there is a next waypoint, the service shall send the next waypoint
    --  in a Mission Command message that references the ID of the Automation
    --  Response message that provided the stored route."
    --
    -- Note two things:
    --  1. this happens "before" we determine if there is a new route that we
    --     we should store and from which we should start streaming waypoints.
    --     So the service will wait one time step before responding to a new
    --     route.
    --
    --  2. we don't update the waypoint_in_msg_id state variable until "after"
    --     we have determined if there's a new route (so that we can use the ID
    --     of the message setting the route to reset the waypoint_in_msg_id).
    --     Thus we manually increment the previous waypoint_in_msg_id here in
    --     building the message.
    out_msg =   if waypoint <> no_waypoint and can_send_message then
                    message {
                        kind     = mission_command;
                        id       = in_id + 1;
                        ref      = no_id -> pre(route_msg_id);
                        route    = no_route -> pre(route);
                        waypoint = waypoint;
                        }
                else
                    no_message;


    frame (route, route_msg_id)
        -- "The stored route shall initially be cleared."
        route = no_route;

        -- "The stored route message ID shall initially be cleared."
        route_msg_id = no_id;
    let
        -- "If the service receives an Automation Response message, the service
        --  shall store the route from the Automation Response message and the
        --  ID of the Automation Response message."
        if in_msg.kind = automation_response and
            nonempty_sequence(in_msg.route)
        then
            route        = in_msg.route;
            route_msg_id = in_msg.id;

        -- "If there is no next waypoint, the service shall clear the stored
        --  route and the stored route message ID."
        elsif waypoint = no_waypoint then
            route        = no_route;
            route_msg_id = no_id;
        fi
    tel


    -- ===================================================================== --
    -- Properties of Interest

    -- This property is a nice sanity check over our output.
    check "Waypoint Manager P1.
      The Waypoint Manager never sends 'no waypoint' as part of a Mission
      Command.\n  "
    (
        out_msg.waypoint <> no_waypoint
    ) provided (
        out_msg.kind = mission_command
    );

    -- This property is a nice sanity check on our stored route.
    check "Waypoint Manager P2.
      Route is no_route xor a (valid) nonempty route.\n  "
    (
        route = no_route xor nonempty_sequence(route)
    );

    check "Waypoint Manager P3.
      A Mission Command message ouput is always preceded by an Automation
      Response message input.\n  "
    (
        O (in_msg.kind = automation_response)
    ) provided (
        out_msg.kind = mission_command
    );

    check "Waypoint Manager P4.
      When the Waypoint Manager sends a Mission Command message, the referenced
      Automation Response message was previously received.\n  "
    (
        exists (m: history(in_msg))
            m.kind = automation_response and
            m.id   = out_msg.ref
    ) provided (
        out_msg.kind = mission_command
    );

    check "Waypoint Manager P6.
      When the Waypoint Manager sends a Mission Command message, the route
      contained in the output message is always contained on a previously
      received Automation Response message.\n  "
    (
        exists (m: history(in_msg))
            m.kind  = automation_response and
            m.route = out_msg.route
    ) provided (
        out_msg.kind = mission_command
    );

    check "Waypoint Manager P7.
      When the Waypoint Manager sends a Mission Command message, the waypoint
      contained in the output message is always contained on the route of a
      previously received Automation Response message.\n  "
    (
        exists (m: history(in_msg))
            m.kind  = automation_response and
            m.route = out_msg.route and
            contains(out_msg.route, out_msg.waypoint)
    ) provided (
        out_msg.kind = mission_command
    );

    check "L1. Lemma for R5.\n  "
    (
        exists (m: history(in_msg))
          m.kind  = automation_response and
          m.route = (no_route -> pre(route)) and
          m.id    = (no_id -> pre(route_msg_id))
    ) provided (
        nonempty_sequence(no_route -> pre(route))
    );

tel;
