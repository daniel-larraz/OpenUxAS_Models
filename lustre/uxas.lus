-- uxas.lus

-- Driver for compositional reasoning about OpenUxAS.

include "common/types.lus"
include "common/pltl.lus"
include "common/bus.lus"

include "services/plan-builder.lus"
include "services/automation-request-validator.lus"
include "services/waypoint-manager.lus"
include "services/task.lus"
include "services/empty-service.lus"


--
-- The OpenUxAS Framework
--
node uxas() returns (
    -- The outputs of uxas are internal state variables that we have chosen to
    -- expose as outputs so that we can select sets of properties more easily
    -- by grouping them into observers.

    -- data received from the bus
    in_msg : message;

    -- the ID of the last nonempty message received on the bus
    last_nonempty_msg_id : id_type;

    -- message sent by the Plan Builder
    pb_msg : message;

    -- message sent by the Automation Request Validator
    arv_msg : message;

    -- message sent by the Waypoint Manager
    wm_msg : message;

    -- message sent by the Task
    task_msg : message;

    -- the service that holds the token
    token_holder : token_holder_type;
);
let
    -- ===================================================================== --
    -- Environment Modeling

    in_msg, token_holder = bus(no_message -> pre(pb_msg),
                               no_message -> pre(arv_msg),
                               no_message -> pre(wm_msg),
                               no_message -> pre(task_msg));

    -- Remember the ID of the last non-empty message seen. We use this to
    -- ensure monotonicity and uniqueness of message IDs.
    last_nonempty_msg_id =  if in_msg <> no_message then
                                in_msg.id
                            else
                                0 -> pre(last_nonempty_msg_id);


    -- ===================================================================== --
    -- Service Execution

    pb_msg   = plan_builder(in_msg, last_nonempty_msg_id,
                            token_holder = plan_builder);
    arv_msg  = automation_request_validator(in_msg, last_nonempty_msg_id,
                                   token_holder = automation_request_validator);
    wm_msg   = waypoint_manager(in_msg, last_nonempty_msg_id,
                                token_holder = waypoint_manager);
    task_msg = task(in_msg, last_nonempty_msg_id,
                    token_holder = task);
tel;


--
-- This observer calls all the other observers for uxas.
--
node uxas_all() returns ();
var
    dummy : bool;
let
    dummy = uxas_ics() and
            uxas_env() and
            uxas_env_witnesses() and
            uxas_props();
tel;


--
-- This observer checks the initial conditions of uxas.
--
node uxas_ics() returns ( _ : bool; );
var
    -- data received from the bus
    in_msg : message;

    -- the ID of the last nonempty message received on the bus
    last_nonempty_msg_id : id_type;

    -- message sent by the Plan Builder
    pb_msg : message;

    -- message sent by the Automation Request Validator
    arv_msg : message;

    -- message sent by the Waypoint Manager
    wm_msg : message;

    -- message sent by the Task
    task_msg : message;

    -- the service that holds the token
    token_holder : token_holder_type;
let
    (in_msg,
     last_nonempty_msg_id,
     pb_msg,
     arv_msg,
     wm_msg,
     task_msg,
     token_holder) = uxas();


    check "Bus IC.\n  "
    (
        O(in_msg = no_message)
    );

    check "ARV IC.\n  "
    (
        O(arv_msg = no_message)
    );

    check "WM IC.\n  "
    (
        O(wm_msg = no_message)
    );

    check "PB IC.\n  "
    (
        O(pb_msg = no_message or pb_msg.kind = unique_automation_response)
    );

    check "Task IC.\n  "
    (
        O(task_msg = no_message)
    );
tel;


--
-- This observer checks "environment" properties - relationships amongst
-- messages and their IDs.
--
node uxas_env() returns ( _ : bool; );
var
    -- data received from the bus
    in_msg : message;

    -- the ID of the last nonempty message received on the bus
    last_nonempty_msg_id : id_type;

    -- message sent by the Plan Builder
    pb_msg : message;

    -- message sent by the Automation Request Validator
    arv_msg : message;

    -- message sent by the Waypoint Manager
    wm_msg : message;

    -- message sent by the Task
    task_msg : message;

    -- the service that holds the token
    token_holder : token_holder_type;
const
    -- used to prove properties about messages in this model
    free_msg1, free_msg2 : message;
let
    (in_msg,
     last_nonempty_msg_id,
     pb_msg,
     arv_msg,
     wm_msg,
     task_msg,
     token_holder) = uxas();


    check "E1:
      nonempty-message IDs are non-decreasing.\n  "
    (
        last_nonempty_msg_id >= (0 -> pre(last_nonempty_msg_id))
    );

    check "E2:
      input IDs are nonnegative.\n  "
    (
        last_nonempty_msg_id >= -1
    );

    check "E3:
      in message IDs are increasing.\n  "
    (
        in_msg.id > (-1 -> pre(in_msg.id))
    ) provided (
        in_msg <> no_message
    );

    check "E4:
      in message IDs are nonnegative.\n  "
    (
        in_msg.id >= 0
    ) provided (
        in_msg <> no_message
    );

    check "E5:
      no_message has ID -1.\n  "
    (
        in_msg.id = -1
    ) provided (
        in_msg = no_message
    );

    -- Note: this property has been lost and needs to be reinvestigated. It's
    -- not required for any proof, but seems interesting.
    -- check "E6:
    --   equal IDs imply equal messages for input messages\n  "
    -- (
    --     ids_imply_equality(free_msg1, free_msg2)
    -- ) provided (
    --     O(in_msg = free_msg1) and
    --     O(in_msg = free_msg2)
    -- );

    check "E7:
      input message source\n  "
    (
        in_msg = (no_message -> pre(pb_msg))   or
        in_msg = (no_message -> pre(arv_msg))  or
        in_msg = (no_message -> pre(wm_msg))   or
        in_msg = (no_message -> pre(task_msg)) or
        in_msg = no_message
    );

    check "E8.
      Input mission command messages were always previously output.\n  "
    (
        O(wm_msg = free_msg1)
    ) provided (
        in_msg.kind = mission_command and
        in_msg      = free_msg1
    );

    check "E9.
      Input automation response messages were always previously output.\n  "
    (
        O(arv_msg = free_msg1)
    ) provided (
        in_msg.kind = automation_response and
        in_msg      = free_msg1
    );
tel;


--
-- This observer poses witnesses for interesting behaviors in the model.
--
node uxas_env_witnesses() returns ( _ : bool; );
var
    -- data received from the bus
    in_msg : message;

    -- the ID of the last nonempty message received on the bus
    last_nonempty_msg_id : id_type;

    -- message sent by the Plan Builder
    pb_msg : message;

    -- message sent by the Automation Request Validator
    arv_msg : message;

    -- message sent by the Waypoint Manager
    wm_msg : message;

    -- message sent by the Task
    task_msg : message;

    -- the service that holds the token
    token_holder : token_holder_type;
let
    (in_msg,
     last_nonempty_msg_id,
     pb_msg,
     arv_msg,
     wm_msg,
     task_msg,
     token_holder) = uxas();


    check reachable "W1. Witness no_message from the bus."
    (
        in_msg = no_message
    );

    check reachable "W2. Witness unique_automation_response from the bus."
    (
        in_msg.kind = unique_automation_response
    );

    check reachable "W3. Witness automation_response from the bus."
    (
        in_msg.kind = automation_response
    );

    check reachable "W4. Witness mission_command from the bus."
    (
        in_msg.kind = mission_command
    );

    check reachable "W5. Witness arv_msg <> no_message."
    (
        arv_msg <> no_message
    );

    check reachable "W6. Witness arv_msg = no_message."
    (
        arv_msg = no_message
    );

    check reachable "W7. Witness wm_msg"
    (
        wm_msg <> no_message
    );

    check reachable "W8. Witness wm_msg = no_message."
    (
        wm_msg = no_message
    );

    check reachable "W9. Witness return to no_message."
    (
        O((none -> pre(in_msg.kind)) = mission_command) and
        in_msg = no_message
    );
tel;


--
-- This observer checks properties on the model.
--
node uxas_props() returns ( _ : bool; );
var
    -- data received from the bus
    in_msg : message;

    -- the ID of the last nonempty message received on the bus
    last_nonempty_msg_id : id_type;

    -- message sent by the Plan Builder
    pb_msg : message;

    -- message sent by the Automation Request Validator
    arv_msg : message;

    -- message sent by the Waypoint Manager
    wm_msg : message;

    -- message sent by the Task
    task_msg : message;

    -- the service that holds the token
    token_holder : token_holder_type;
let
    (in_msg,
     last_nonempty_msg_id,
     pb_msg,
     arv_msg,
     wm_msg,
     task_msg,
     token_holder) = uxas();


    -- ===================================================================== --
    -- Properties about Message Sending

    check "Messages P1.
      PB sends only Automation Request messages.\n  "
    (
        in_msg      = no_message xor
        in_msg.kind = unique_automation_response
    ) provided (
        false -> (pre(token_holder) = plan_builder)
    );

    check "Messages P1.1.
      Only the Plan Builder sends Unique Automation Response messages.\n  "
    (
        true -> (pre(token_holder) = plan_builder)
    ) provided (
        in_msg.kind = unique_automation_response
    );

    check "Messages P2.
      ARV sends only Automation Response messages.\n  "
    (
        in_msg      = no_message xor
        in_msg.kind = automation_response
    ) provided (
        false -> (pre(token_holder) = automation_request_validator)
    );

    check "Messages P2.1.
      Only the ARV sends Automation Response messages.\n  "
    (
        true -> (pre(token_holder) = automation_request_validator)
    ) provided (
        in_msg.kind = automation_response
    );

    check "Messages P3.
      WM sends only Mission Command messages.\n  "
    (
        in_msg      = no_message xor
        in_msg.kind = mission_command
    ) provided (
        false -> (pre(token_holder) = waypoint_manager)
    );

    check "Messages P3.1
      Only the WM sends Mission Command messages.\n  "
    (
        true -> (pre(token_holder) = waypoint_manager)
    ) provided (
        in_msg.kind = mission_command
    );

    check "Messages P4.
      Task sends only Task Complete or Error messages.\n  "
    (
        in_msg      = no_message xor
        in_msg.kind = task_complete xor
        in_msg.kind = error_response
    ) provided (
        false -> (pre(token_holder) = task)
    );

    check "Messages P4.1
      Only the Task sends Task Complete or Error messages.\n  "
    (
        true -> (pre(token_holder) = task)
    ) provided (
        in_msg.kind = task_complete or in_msg.kind = error_response
    );


    -- ===================================================================== --
    -- Properties of Interest

    check "P1.
      All services correctly handle input ID and message ID.\n  "
    (
        in_msg.id > (no_id -> pre(last_nonempty_msg_id))
    ) provided (
        in_msg <> no_message
    );

    check "P2.
      Reestablish Waypoint Manager R5.\n  "
    (
        exists (m: history(in_msg))
          m.kind  = automation_response and
          m.id    = in_msg.ref and
          m.route = in_msg.route and
          contains(in_msg.route, in_msg.waypoint)
    ) provided (
        in_msg.kind = mission_command
    );

    check "P2.1.
      The route on a Mission Command message is the same route on a prior
      Unique Automation Response message.\n  "
    (
        exists (m: history(in_msg))
          m.kind  = automation_response and
          m.route = in_msg.route
    ) provided (
        in_msg.kind = mission_command
    );

    check "P3.
      Reestablish Automation Request Validator R5.\n  "
    (
        exists (m: history(in_msg))
          m.kind = unique_automation_response and
          m.id = in_msg.ref and
          m.route = in_msg.route

    ) provided (
        in_msg.kind = automation_response
    );

    check "P3.1.
      The route on an Automation Response message is the same route on a prior
      Unique Automation Response message.\n  "
    (
        exists (m: history(in_msg))
          m.kind = unique_automation_response and
          m.route = in_msg.route

    ) provided (
        in_msg.kind = automation_response
    );

    check "P3.2.
      An Automation Response is always preceded by an associated Unique Automation Response
      message.\n  "
    (
        exists (m: history(in_msg))
          m.kind = unique_automation_response and
          m.id = in_msg.ref

    ) provided (
        in_msg.kind = automation_response
    );

    check "P3.3.
      An Automation Response is always preceded by a Unique Automation Response
      message.\n  "
    (
        exists (m: history(in_msg))
          m.kind = unique_automation_response
    ) provided (
        in_msg.kind = automation_response
    );

    check "P4.
      Reestablish Task R4.\n  "
    (
        exists (m: history(in_msg))
          m.kind = automation_response and
          m.route = in_msg.route
    ) provided (
        in_msg.kind = task_complete
    );


    -- ===================================================================== --
    -- Compositional Properties of Interest

    -- This property cannot currently be proven.
    -- check "C.1
    --   Mission Command messages reference, transitively, prior Unique Automation
    --   Response messages.\n  "
    -- (
    --     exists (link_msg: history(in_msg); final_msg: history(in_msg))
    --         link_msg.id = in_msg.ref and
    --         link_msg.kind = automation_response and

    --         final_msg.kind = unique_automation_response and
    --         final_msg.id = link_msg.ref
    -- ) provided (
    --     in_msg.kind = mission_command
    -- );

    check "L2. Candidate lemma for C1"
    (
      in_msg.kind = mission_command
      =>
      exists (link_msg: history(in_msg))
        link_msg.kind = automation_response and
        link_msg.id = in_msg.ref and
        (
          exists (final_msg: history(in_msg))
            final_msg.kind = unique_automation_response
        )
    );

    check "L1. Lemma for L2"
    (
      (exists (link_msg: history(in_msg))
        link_msg.kind = automation_response
      )
      =
      (exists (link_msg: history(in_msg))
        link_msg.kind = automation_response and
        exists (final_msg: history(in_msg))
          final_msg.kind = unique_automation_response and
          final_msg.id = link_msg.ref
      )
    );

    -- This property cannot currently be proven.
    -- check "C1.1.
    --   Mission Command messages contain routes that, transitively, were on prior
    --   Unique Automation Response messages.\n  "
    -- (
    --     exists (link_msg: history(in_msg); final_msg: history(in_msg))
    --         link_msg.id = in_msg.ref and
    --         link_msg.kind = automation_response and

    --         final_msg.kind = unique_automation_response and
    --         final_msg.route = link_msg.route
    -- ) provided (
    --     in_msg.kind = mission_command
    -- );

    -- Kind 2's parser (up to v2.2.0) does not support this property
    -- because the quantified variable 'final_msg' cannot be used as
    -- an argument in the 'contains' function call.
    -- check "C2.
    --   Mission Command message waypoints are contained, transitively, on prior
    --   received Unique Automation Response messages.\n  "
    -- (
    --     exists (link_msg: history(in_msg); final_msg: history(in_msg))
    --         link_msg.id = in_msg.ref and
    --         link_msg.kind = automation_response and

    --         final_msg.kind = unique_automation_response and
    --         final_msg.id = link_msg.ref and
    --         contains(final_msg.route, in_msg.waypoint)
    -- ) provided (
    --     in_msg.kind = mission_command
    -- );

    -- This property, as stated, is falsifiable from our contracts.
    -- check "C3.
    --   The monitored route on a Task Complete message was contained in a prior
    --   Unique Automation Response message.\n  "
    -- (
    --     exists (link_msg: history(in_msg); final_msg: history(in_msg))
    --         link_msg.id = in_msg.ref and
    --         link_msg.kind = automation_response and

    --         final_msg.kind = unique_automation_response and
    --         final_msg.route = link_msg.route
    -- ) provided (
    --     in_msg.kind = task_complete
    -- );
tel;
